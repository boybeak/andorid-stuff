## 设计一个图片加载库，需要考虑哪些功能（缓存策略、线程池、生命周期绑定等）？

设计一个图片加载库时，需要考虑的功能和模块很多，下面列出一些关键的方面及其细节说明：

1. **数据源与加载方式**  
   - **多数据源支持**：不仅需要支持网络加载，还要支持本地文件、资源文件甚至内存中的图片数据。  
   - **解码与格式支持**：支持常见的图片格式（JPEG、PNG、GIF、WebP 等），并能根据需求进行解码，甚至支持动态图（如 GIF、WebP 动画）。

2. **缓存策略**  
   - **内存缓存**：  
     - 采用 LRU（最近最少使用）等算法管理内存缓存，快速响应重复请求，提升加载速度。  
     - 考虑使用软引用/弱引用等手段降低内存溢出风险。  
   - **磁盘缓存**：  
     - 持久化缓存图片，减少网络请求；同样可以采用 LRU 算法管理。  
     - 支持缓存大小限制、过期策略以及主动清理功能。  
   - **双缓存策略**：内存缓存与磁盘缓存结合，既保证了快速加载又节省网络资源。

3. **线程池与异步加载**  
   - **线程池管理**：  
     - 使用线程池进行图片加载、解码等耗时操作，避免阻塞 UI 线程。  
     - 动态调整线程数量和优先级，防止线程过多导致资源竞争。  
   - **任务调度与取消**：  
     - 支持任务排队、优先级调度，保证重要任务（例如当前页面显示的图片）优先加载。  
     - 当视图复用或界面退出时，能及时取消对应任务，避免无效加载和资源浪费。

4. **生命周期绑定**  
   - **与组件生命周期关联**：  
     - 对接 Activity/Fragment 或自定义 View 的生命周期，确保在组件销毁时取消相关任务，防止内存泄漏。  
     - 在特定生命周期（如 onPause、onStop）时，提供暂停、恢复加载的机制。
   
5. **图片变换与处理**  
   - **基本变换**：支持图片的缩放、裁剪、旋转、圆角、模糊等常用效果。  
   - **链式调用与自定义扩展**：允许开发者通过 API 链式配置多种变换逻辑，甚至接入自定义的图片处理算法。  
   - **分辨率与尺寸优化**：根据 ImageView 或目标控件的尺寸，动态调整图片尺寸，减少内存消耗和提高加载速度。

6. **占位图与错误处理**  
   - **占位图**：在图片加载过程中，显示占位图以提升用户体验。  
   - **错误图和重试机制**：加载失败时显示默认错误图，支持重试机制（可配置重试次数、间隔等）。

7. **内存管理与资源优化**  
   - **防止内存泄漏**：合理管理缓存和异步任务，及时释放无用资源。  
   - **低内存处理**：在系统内存紧张时，能自动清理缓存或降低图片质量，防止应用崩溃。

8. **日志与调试支持**  
   - **详细日志记录**：记录加载过程、缓存命中、错误信息等，便于开发者调试。  
   - **调试工具**：提供调试模式或工具，帮助分析性能瓶颈和内存使用情况。

9. **API 设计与扩展性**  
   - **简洁易用的接口**：提供友好的 API，让开发者能简单快速地使用库加载图片。  
   - **模块化设计**：各功能模块（如缓存、网络请求、图片变换）应模块化，方便后期扩展和替换。  
   - **开放接口**：允许开发者自定义缓存策略、图片解码器、加载器等，适应不同场景需求。

10. **其他考虑**  
    - **动画效果**：加载完成后提供渐变、淡入等动画效果，提高用户体验。  
    - **配置灵活性**：允许用户通过配置文件或代码动态调整加载参数、缓存策略、线程池参数等。  
    - **多平台支持**：若需要跨平台使用（如 Android、iOS、桌面等），考虑不同平台的特性和限制，设计统一或适配的 API。

综合以上各个方面，设计一个图片加载库不仅要关注图片的快速加载和显示，还需要从性能、内存管理、用户体验以及开发者扩展性等多个角度出发，构建一个稳定、灵活且易于使用的库。




## 如何实现一个全局的ANR监控系统？（提示：WatchDog原理）

要实现一个 **全局 ANR（Application Not Responding）监控系统**，可以借鉴 `WatchDog` 的原理，即**通过定期检查主线程的响应状态**来判断是否发生了 ANR。以下是具体的实现方案：

---

## **核心原理**
- **主线程阻塞检测**：ANR 发生时，主线程通常会被长时间阻塞。因此，可以启动一个**后台线程**，定期检查主线程是否仍然在响应（即执行了新的消息）。
- **基于 Looper 检测**：
  - 在主线程的 `MessageQueue` 中插入任务。
  - 后台线程等待一段时间后检查该任务是否执行。
  - 如果超时未执行，说明主线程可能发生了 ANR。

---

## **实现方案**

### **1. 关键步骤**
- 启动一个**后台线程**（WatchDog）。
- 让**主线程定期执行**一个 "标记任务"（Runnable）。
- 在后台线程检查该任务是否**在规定时间内执行**：
  - 若超时（例如 5 秒），则可能是 ANR，记录堆栈信息并上报。

---

### **2. 代码实现**
```kotlin
class ANRMonitor(private val timeout: Long = 5000L) {
    @Volatile
    private var lastTick: Long = 0
    private val handler = Handler(Looper.getMainLooper())

    private val tickRunnable = object : Runnable {
        override fun run() {
            lastTick = System.currentTimeMillis()
            handler.postDelayed(this, timeout / 2) // 定期刷新时间
        }
    }

    fun start() {
        lastTick = System.currentTimeMillis()
        handler.post(tickRunnable) // 让主线程开始执行任务

        // 监控线程，定期检查主线程是否响应
        Thread {
            while (true) {
                try {
                    Thread.sleep(timeout)
                    val current = System.currentTimeMillis()
                    if (current - lastTick > timeout) {
                        detectANR()
                    }
                } catch (e: InterruptedException) {
                    e.printStackTrace()
                }
            }
        }.start()
    }

    private fun detectANR() {
        val stackTrace = Looper.getMainLooper().thread.stackTrace
        Log.e("ANRMonitor", "可能发生 ANR！主线程堆栈信息：")
        for (element in stackTrace) {
            Log.e("ANRMonitor", element.toString())
        }
    }
}
```
---

### **3. 代码解析**
1. **主线程定期执行 `tickRunnable`**：
   - `lastTick` 记录最后一次执行的时间。
   - 每隔 `timeout / 2` 毫秒，主线程都会更新 `lastTick`，表示它仍然在执行任务。
   
2. **后台线程定期检查 `lastTick`**：
   - 如果超过 `timeout` 仍未更新 `lastTick`，说明主线程可能发生了 ANR。
   - 读取主线程堆栈信息，并进行日志记录或上报。

---

### **4. 进一步优化**
#### **(1) 监听 Looper 机制**
利用 `Looper.getMainLooper().setMessageLogging()` 监听 `MessageQueue`，检查是否长时间没有处理消息：
```kotlin
Looper.getMainLooper().setMessageLogging { log ->
    Log.d("ANRMonitor", "Looper 事件：$log")
}
```
如果长时间没有新消息被消费，说明主线程可能被卡住。

#### **(2) 结合 `SIGQUIT` 信号**
在某些 Android 版本上，可以监听 `/data/anr/traces.txt` 或 `SIGQUIT` 信号，以检测系统 ANR 事件。

#### **(3) 结合 `BlockCanary` 监控**
可使用 `BlockCanary` 进一步分析方法级别的耗时调用，定位具体的 ANR 发生点。

---

## **总结**
- 通过**后台线程**定期检查主线程是否响应，实现 ANR 监控。
- 结合**主线程 Looper 日志**和**堆栈分析**，获取详细信息。
- 进一步优化可结合**信号监听**和**BlockCanary** 进行深入分析。

这样就能实现一个**全局 ANR 监控系统**，帮助开发者快速发现和定位问题！ 🚀